{
  "project": "OpenCode",
  "branchName": "ralph/security-access-control",
  "description": "Security Access Control - Protect confidential directories, files, and code segments from unauthorized access, editing, and LLM transmission with role-based permissions",
  "userStories": [
    {
      "id": "US-001",
      "title": "Create security configuration schema",
      "description": "As a developer, I need a well-defined Zod schema for `.opencode-security.json` so that security rules can be consistently parsed and validated.",
      "acceptanceCriteria": [
        "Create new file `src/security/schema.ts` with Zod schema",
        "Schema supports `version` string field",
        "Schema supports `roles` array with objects containing `name` (string) and `level` (number)",
        "Schema supports `rules` array with objects containing `pattern` (glob string), `type` ('directory' | 'file'), `deniedOperations` (array of 'read' | 'write' | 'llm'), `allowedRoles` (string array)",
        "Schema supports `segments.markers` array for comment-based protection with `start`, `end`, `deniedOperations`, `allowedRoles`",
        "Schema supports `segments.ast` array for AST-based protection with `languages`, `nodeTypes`, `namePattern`, `deniedOperations`, `allowedRoles`",
        "Schema supports `logging` object with `path`, `level`, `maxSizeMB`, `retentionDays`",
        "Schema supports `authentication` object with `publicKey` and `revokedTokens` array",
        "Schema supports `mcp` object with `defaultPolicy` and `servers` record",
        "Export `SecurityConfig` type and `securityConfigSchema` validator",
        "Typecheck passes"
      ],
      "priority": 1,
      "passes": true,
      "notes": ""
    },
    {
      "id": "US-002",
      "title": "Implement configuration loader",
      "description": "As a developer, I need to load and validate security configuration from project root so that protection rules are available at runtime.",
      "acceptanceCriteria": [
        "Create new file `src/security/config.ts`",
        "Function `loadSecurityConfig(projectRoot: string)` loads `.opencode-security.json`",
        "Validate loaded config against schema from US-001",
        "If config is malformed, log warning and return empty config (fail-open behavior)",
        "If file doesn't exist, return default empty config with no rules",
        "Export `getSecurityConfig()` function to access current config",
        "Typecheck passes"
      ],
      "priority": 2,
      "passes": true,
      "notes": ""
    },
    {
      "id": "US-003",
      "title": "Implement path-based access checker",
      "description": "As a developer, I need a centralized access checking function so that all tools can verify permissions consistently.",
      "acceptanceCriteria": [
        "Create new file `src/security/access.ts`",
        "Function `checkAccess(path: string, operation: 'read' | 'write' | 'llm', role: string)` returns `{ allowed: boolean, reason?: string }`",
        "Match paths against rules using glob patterns (use micromatch or similar)",
        "Respect role hierarchy: higher level roles can access content allowed for lower levels",
        "Return clear denial reason string when access is denied",
        "Export `checkAccess` function",
        "Typecheck passes"
      ],
      "priority": 3,
      "passes": true,
      "notes": ""
    },
    {
      "id": "US-004",
      "title": "Implement rule inheritance for subdirectories",
      "description": "As a security admin, I want protection rules to be inherited by subdirectories so that I don't need to specify rules for every nested path.",
      "acceptanceCriteria": [
        "Update `checkAccess` in `src/security/access.ts`",
        "Child paths automatically inherit parent directory protection rules",
        "More restrictive child rules take precedence over inherited rules",
        "Less restrictive child rules do NOT override parent restrictions",
        "Add `getInheritanceChain(path: string)` function that returns array of applicable rules",
        "Typecheck passes"
      ],
      "priority": 4,
      "passes": true,
      "notes": ""
    },
    {
      "id": "US-005",
      "title": "Implement symbolic link resolution for access checks",
      "description": "As a security admin, I want symbolic links to protected content to be handled safely so that users cannot bypass protection via symlinks.",
      "acceptanceCriteria": [
        "Update `checkAccess` in `src/security/access.ts`",
        "Resolve symbolic link targets using `fs.realpath` before checking access rules",
        "If symlink target is protected, deny access to the symlink",
        "Handle chains of symlinks (resolve fully before checking)",
        "Return specific reason 'symlink target is protected' when symlink points to protected content",
        "Typecheck passes"
      ],
      "priority": 5,
      "passes": true,
      "notes": ""
    },
    {
      "id": "US-006",
      "title": "Implement marker-based segment detector",
      "description": "As a developer, I need to detect protected code segments via comment markers so that teams can easily mark sensitive code blocks.",
      "acceptanceCriteria": [
        "Create new file `src/security/segments.ts`",
        "Function `findMarkerSegments(content: string, markers: MarkerConfig[])` returns array of `{ start: number, end: number, rule: MarkerConfig }`",
        "Support common comment styles: `//`, `#`, `<!-- -->`",
        "Handle nested markers correctly (inner markers inherit outer protection)",
        "Handle multiple separate marker blocks in same file",
        "Export `findMarkerSegments` function",
        "Typecheck passes"
      ],
      "priority": 6,
      "passes": true,
      "notes": ""
    },
    {
      "id": "US-007",
      "title": "Implement AST-based segment detector for TypeScript/JavaScript",
      "description": "As a developer, I need to detect protected code segments via AST analysis so that functions and classes can be protected by name pattern.",
      "acceptanceCriteria": [
        "Update `src/security/segments.ts`",
        "Function `findASTSegments(filePath: string, content: string, astRules: ASTConfig[])` returns array of `{ start: number, end: number, rule: ASTConfig, nodeType: string }`",
        "Use TypeScript compiler API to parse TS/JS files",
        "Detect function declarations, arrow functions, class declarations, and class methods",
        "Match function/class names against regex patterns from config",
        "Graceful fallback: return empty array if parsing fails",
        "Export `findASTSegments` function",
        "Typecheck passes"
      ],
      "priority": 7,
      "passes": true,
      "notes": ""
    },
    {
      "id": "US-008",
      "title": "Implement content redaction utility",
      "description": "As a developer, I need a utility to redact protected segments from file content so that tools can safely return partial content.",
      "acceptanceCriteria": [
        "Create new file `src/security/redact.ts`",
        "Function `redactContent(content: string, segments: Segment[])` returns content with protected ranges replaced by `[REDACTED: Security Protected]`",
        "Preserve line numbers (replace with same number of newlines if multi-line)",
        "Handle overlapping segments correctly (merge overlapping ranges)",
        "Export `redactContent` function",
        "Typecheck passes"
      ],
      "priority": 8,
      "passes": true,
      "notes": ""
    },
    {
      "id": "US-009",
      "title": "Integrate access control with Read tool",
      "description": "As a user, I want the Read tool to respect security rules so that protected content cannot be read.",
      "acceptanceCriteria": [
        "Locate Read tool implementation in `src/tool/` directory",
        "Before reading file, call `checkAccess(path, 'read', currentRole)`",
        "If file is fully protected (directory/file rule), return access denied error",
        "If file contains protected segments, read file and apply `redactContent()` before returning",
        "Log access attempt using security logger (create placeholder if not exists)",
        "Typecheck passes"
      ],
      "priority": 9,
      "passes": true,
      "notes": ""
    },
    {
      "id": "US-010",
      "title": "Integrate access control with Write tool",
      "description": "As a user, I want the Write tool to respect security rules so that protected content cannot be overwritten.",
      "acceptanceCriteria": [
        "Locate Write tool implementation in `src/tool/` directory",
        "Before writing file, call `checkAccess(path, 'write', currentRole)`",
        "If file is protected, return access denied error with clear message",
        "Log write attempt using security logger",
        "Typecheck passes"
      ],
      "priority": 10,
      "passes": true,
      "notes": ""
    },
    {
      "id": "US-011",
      "title": "Integrate access control with Edit tool",
      "description": "As a user, I want the Edit tool to respect security rules so that protected segments cannot be modified.",
      "acceptanceCriteria": [
        "Locate Edit tool implementation in `src/tool/` directory",
        "Before editing, call `checkAccess(path, 'write', currentRole)` for file-level check",
        "If file has protected segments, check if edit range overlaps with any protected segment",
        "If edit would modify protected segment, return access denied error",
        "Log edit attempt using security logger",
        "Typecheck passes"
      ],
      "priority": 11,
      "passes": true,
      "notes": ""
    },
    {
      "id": "US-012",
      "title": "Integrate access control with Glob tool",
      "description": "As a user, I want the Glob tool to respect security rules so that protected files are filtered from results.",
      "acceptanceCriteria": [
        "Locate Glob tool implementation in `src/tool/` directory",
        "After getting glob results, filter out paths where `checkAccess(path, 'read', currentRole).allowed` is false",
        "Log that protected files were filtered (count only, not paths)",
        "Typecheck passes"
      ],
      "priority": 12,
      "passes": true,
      "notes": ""
    },
    {
      "id": "US-013",
      "title": "Integrate access control with Grep tool",
      "description": "As a user, I want the Grep tool to respect security rules so that matches in protected content are hidden.",
      "acceptanceCriteria": [
        "Locate Grep tool implementation in `src/tool/` directory",
        "Filter out matches in fully protected files",
        "For files with protected segments, redact match content if it falls within protected range (show file:line but not content)",
        "Log that protected content was redacted from results",
        "Typecheck passes"
      ],
      "priority": 13,
      "passes": false,
      "notes": ""
    },
    {
      "id": "US-014",
      "title": "Implement audit logging system",
      "description": "As a security admin, I want all access attempts logged so that I can review security events.",
      "acceptanceCriteria": [
        "Create new file `src/security/audit.ts`",
        "Function `logSecurityEvent(event: SecurityEvent)` writes to configured log path",
        "Log format: JSON with timestamp, role, operation, path, result (allowed/denied), rule triggered",
        "Support configurable log level: 'verbose' (all access) or 'normal' (denials only)",
        "Hash or truncate actual content in logs (don't store sensitive data)",
        "Export `logSecurityEvent` function",
        "Typecheck passes"
      ],
      "priority": 14,
      "passes": false,
      "notes": ""
    },
    {
      "id": "US-015",
      "title": "Implement Bash command security scanner",
      "description": "As a user, I want the Bash tool to detect commands that would access protected files so that shell commands cannot bypass protection.",
      "acceptanceCriteria": [
        "Create new file `src/security/bash-scanner.ts`",
        "Function `scanBashCommand(command: string)` returns array of file paths the command may access",
        "Detect file access patterns in: cat, less, head, tail, vim, nano, grep, find, sed, awk",
        "Parse basic command arguments to extract file paths",
        "Export `scanBashCommand` function",
        "Typecheck passes"
      ],
      "priority": 15,
      "passes": false,
      "notes": ""
    },
    {
      "id": "US-016",
      "title": "Integrate access control with Bash tool",
      "description": "As a user, I want the Bash tool to block commands that would access protected files.",
      "acceptanceCriteria": [
        "Locate Bash tool implementation in `src/tool/` directory",
        "Before executing command, call `scanBashCommand()` to get potential file accesses",
        "Check each detected path with `checkAccess(path, 'read' or 'write', currentRole)`",
        "If any path is protected, return error explaining which rule was triggered",
        "Log blocked command attempts",
        "Typecheck passes"
      ],
      "priority": 16,
      "passes": false,
      "notes": ""
    },
    {
      "id": "US-017",
      "title": "Implement LLM request content scanner",
      "description": "As a security admin, I need to scan outgoing LLM request content for protected patterns.",
      "acceptanceCriteria": [
        "Create new file `src/security/llm-scanner.ts`",
        "Function `scanForProtectedContent(content: string, config: SecurityConfig)` returns array of matches with rule info",
        "Check content against all configured segment markers and patterns",
        "Return match locations and which rule was triggered",
        "Export `scanForProtectedContent` function",
        "Typecheck passes"
      ],
      "priority": 17,
      "passes": false,
      "notes": ""
    },
    {
      "id": "US-018",
      "title": "Implement LLM request interceptor middleware",
      "description": "As a security admin, I want all LLM requests to be intercepted so that protected content never reaches external providers.",
      "acceptanceCriteria": [
        "Locate LLM provider code in `src/provider/` directory",
        "Create middleware that intercepts outgoing requests before sending",
        "Scan all message content and tool results using `scanForProtectedContent()`",
        "If protected content detected and rule says 'block', throw error",
        "If protected content detected and rule says 'redact', replace with placeholder",
        "Log all interceptions to audit log",
        "Typecheck passes"
      ],
      "priority": 18,
      "passes": false,
      "notes": ""
    },
    {
      "id": "US-019",
      "title": "Add MCP server security policy support",
      "description": "As a security admin, I want to configure security policies per MCP server so that external tools follow appropriate rules.",
      "acceptanceCriteria": [
        "Update security config loader to read `mcp.defaultPolicy` and `mcp.servers` settings",
        "Create function `getMcpPolicy(serverName: string)` returning 'enforced' | 'trusted' | 'blocked'",
        "Locate MCP tool handler in codebase",
        "Before MCP tool execution, check server policy",
        "If 'blocked', reject the tool call",
        "If 'enforced', apply normal security checks to tool inputs/outputs",
        "If 'trusted', skip security checks",
        "Log MCP access with server name",
        "Typecheck passes"
      ],
      "priority": 19,
      "passes": false,
      "notes": ""
    },
    {
      "id": "US-020",
      "title": "Implement nested config detection and merging",
      "description": "As a developer in a monorepo, I want nested security configs to merge with parent configs so each subproject can add restrictions.",
      "acceptanceCriteria": [
        "Update `src/security/config.ts`",
        "Function `findSecurityConfigs(startPath: string)` walks up to git root collecting `.opencode-security.json` files",
        "Function `mergeSecurityConfigs(configs: SecurityConfig[])` combines configs",
        "Rules are unioned (more configs = more restrictions)",
        "Role definitions must be identical across configs (throw error if conflict)",
        "MCP policies use most restrictive (blocked > enforced > trusted)",
        "Typecheck passes"
      ],
      "priority": 20,
      "passes": false,
      "notes": ""
    },
    {
      "id": "US-021",
      "title": "Add security CLI status command",
      "description": "As a user, I want a CLI command to see current security status so I understand my access level.",
      "acceptanceCriteria": [
        "Create new CLI command file `src/cli/cmd/security/status.ts`",
        "Command `opencode security status` shows: current role, number of active rules, config file paths",
        "Register command in CLI command registry",
        "Format output clearly with sections for role, rules count by type, active config files",
        "Typecheck passes"
      ],
      "priority": 21,
      "passes": false,
      "notes": ""
    },
    {
      "id": "US-022",
      "title": "Add security CLI check command",
      "description": "As a user, I want to test if a specific path is accessible so I can verify security config.",
      "acceptanceCriteria": [
        "Create new CLI command file `src/cli/cmd/security/check.ts`",
        "Command `opencode security check <path>` tests path accessibility",
        "Show result for each operation type (read/write/llm)",
        "Show inheritance chain (which rules apply and from where)",
        "Show symlink resolution if path is symlink",
        "Typecheck passes"
      ],
      "priority": 22,
      "passes": false,
      "notes": ""
    },
    {
      "id": "US-023",
      "title": "Add security CLI init command",
      "description": "As a user, I want to generate a template security config so I can quickly set up protection.",
      "acceptanceCriteria": [
        "Create new CLI command file `src/cli/cmd/security/init.ts`",
        "Command `opencode security init` creates template `.opencode-security.json`",
        "Template includes example roles (admin, developer, viewer)",
        "Template includes example rules for common sensitive paths (.env, secrets/)",
        "Template includes example segment markers",
        "Don't overwrite if file already exists (prompt or error)",
        "Typecheck passes"
      ],
      "priority": 23,
      "passes": false,
      "notes": ""
    },
    {
      "id": "US-024",
      "title": "Add security CLI logs command",
      "description": "As a security admin, I want to view recent audit logs from the CLI.",
      "acceptanceCriteria": [
        "Create new CLI command file `src/cli/cmd/security/logs.ts`",
        "Command `opencode security logs` shows recent security events",
        "Support `--tail <n>` flag to show last N entries (default 20)",
        "Support `--filter denied` to show only denials",
        "Parse and format JSON log entries for readability",
        "Handle missing log file gracefully",
        "Typecheck passes"
      ],
      "priority": 24,
      "passes": false,
      "notes": ""
    },
    {
      "id": "US-025",
      "title": "Add security status indicator to TUI header",
      "description": "As a user, I want to see my security role in the TUI so I understand my current access level.",
      "acceptanceCriteria": [
        "Locate TUI header/status bar component in `src/cli/cmd/tui/`",
        "Add security status indicator showing current role name",
        "Show indicator only when security config is active (has rules)",
        "Use subtle styling (not intrusive)",
        "Typecheck passes",
        "Verify in browser using dev-browser skill"
      ],
      "priority": 25,
      "passes": false,
      "notes": ""
    },
    {
      "id": "US-026",
      "title": "Implement JWT token verification for role authentication",
      "description": "As a security admin, I want roles verified via signed tokens so users cannot falsely claim privileges.",
      "acceptanceCriteria": [
        "Create new file `src/security/token.ts`",
        "Function `verifyRoleToken(tokenPath: string, publicKey: string)` returns `{ valid: boolean, role?: string, error?: string }`",
        "Parse JWT token and verify RS256 signature against public key",
        "Check token expiration (exp claim)",
        "Check token is not in revokedTokens list (by jti claim)",
        "Return role from token claims if valid",
        "Export `verifyRoleToken` function",
        "Typecheck passes"
      ],
      "priority": 26,
      "passes": false,
      "notes": ""
    },
    {
      "id": "US-027",
      "title": "Implement current role detection",
      "description": "As a user, I want my role to be automatically detected from token file so I get appropriate access.",
      "acceptanceCriteria": [
        "Create new file `src/security/role.ts`",
        "Function `getCurrentRole(projectRoot: string, config: SecurityConfig)` returns role name string",
        "Look for `.opencode-role.token` in project root first, then `~/.config/opencode/role.token`",
        "Verify token using `verifyRoleToken()` with public key from config",
        "If no valid token found, return lowest level role from config",
        "Cache result for session (don't re-verify on every check)",
        "Export `getCurrentRole` function",
        "Typecheck passes"
      ],
      "priority": 27,
      "passes": false,
      "notes": ""
    },
    {
      "id": "US-028",
      "title": "Add CLI command to generate admin key pair",
      "description": "As a security admin, I want to generate a key pair for signing role tokens.",
      "acceptanceCriteria": [
        "Create new CLI command file `src/cli/cmd/security/init-keys.ts`",
        "Command `opencode security init-keys` generates RSA key pair",
        "Support optional `--passphrase` flag for encrypting private key",
        "Save private key to `.opencode-security-key.pem` (add to .gitignore warning)",
        "Output public key in PEM format to add to security config",
        "Typecheck passes"
      ],
      "priority": 28,
      "passes": false,
      "notes": ""
    },
    {
      "id": "US-029",
      "title": "Add CLI command to issue role tokens",
      "description": "As a security admin, I want to generate signed tokens so team members can authenticate their role.",
      "acceptanceCriteria": [
        "Create new CLI command file `src/cli/cmd/security/issue-token.ts`",
        "Command `opencode security issue-token --role <role> --expires <days>`",
        "Load private key from `.opencode-security-key.pem`",
        "Support `--passphrase` flag if key is encrypted",
        "Generate JWT with claims: role, project (git remote), exp, iat, jti (unique ID)",
        "Output token to stdout or save to file with `--output` flag",
        "Typecheck passes"
      ],
      "priority": 29,
      "passes": false,
      "notes": ""
    },
    {
      "id": "US-030",
      "title": "Register all security CLI commands",
      "description": "As a user, I want all security commands available under `opencode security` subcommand.",
      "acceptanceCriteria": [
        "Create `src/cli/cmd/security/index.ts` to register subcommands",
        "Register: status, check, init, logs, init-keys, issue-token",
        "Add `security` command group to main CLI registry",
        "Add help text for `opencode security --help`",
        "Typecheck passes"
      ],
      "priority": 30,
      "passes": false,
      "notes": ""
    }
  ]
}
