{
  "project": "OpenCode",
  "branchName": "ralph/cold-start-optimization",
  "description": "Cold Start Optimization - Systematically optimize startup performance through profiling, blocking elimination, parallelization, and lazy loading",
  "userStories": [
    {
      "id": "US-001",
      "title": "Complete cold start profiling infrastructure (--startup-trace)",
      "description": "As a developer, I need a --startup-trace CLI flag that outputs complete per-phase durations to stderr in JSON format, covering all startup phases beyond InstanceBootstrap.",
      "acceptanceCriteria": [
        "Add --startup-trace CLI flag that outputs per-phase durations to stderr in JSON format",
        "Extend timing coverage beyond InstanceBootstrap to: global-init, log-init, worker-spawn, terminal-bg-detect, resolve-network-options, project-detect, git-metadata, config-load (with sub-phases: remote-fetch, global-config, project-config, directory-scan), server-init",
        "Support nested timing output format: { phase: string, duration_ms: number, children?: [...] }",
        "No impact on normal startup performance (timing code always collects, only outputs to stderr when flag is enabled)",
        "Existing InstanceBootstrap() timing and /bootstrap endpoint preserved",
        "Typecheck passes"
      ],
      "priority": 1,
      "passes": true,
      "notes": ""
    },
    {
      "id": "US-002",
      "title": "Optimize terminal background color detection (~1000ms savings)",
      "description": "As a developer, I want terminal background color detection to not block TUI rendering so the first frame appears immediately. Currently getTerminalBackgroundColor() blocks up to 1000ms waiting for terminal response.",
      "acceptanceCriteria": [
        "getTerminalBackgroundColor() in app.tsx no longer blocks TUI first-frame rendering beyond 200ms",
        "Cache detection result to KV store — subsequent launches use cache directly (0ms blocking)",
        "If no cache (first launch): reduce detection timeout from 1000ms to 150ms",
        "Consider using COLORFGBG environment variable for fast inference, skipping terminal query when available",
        "Provide a mechanism for users to manually trigger re-detection (clear cache + re-detect)",
        "Fallback behavior unchanged: default to 'dark' when detection fails",
        "Typecheck passes"
      ],
      "priority": 2,
      "passes": true,
      "notes": ""
    },
    {
      "id": "US-003",
      "title": "Optimize Log.init() to not block startup",
      "description": "As a developer, I want Log.init() to not block the startup critical path. Currently await fs.truncate() in Log.init() blocks both main thread (yargs middleware) and worker thread (module top-level await).",
      "acceptanceCriteria": [
        "Change Log.init() to synchronous initialization, no await on any IO",
        "Buffer logs to an in-memory array first, independent of whether directories exist",
        "After Global.ensureDirectories() completes, call Log.flush() or similar mechanism to write buffer to disk and switch to direct-write mode",
        "Add .catch(() => {}) to cleanup() fire-and-forget call to prevent unhandled rejections",
        "Make await fs.truncate(logpath) non-blocking — either remove await or make truncation lazy",
        "Verify actual timing improvement after optimization",
        "Typecheck passes"
      ],
      "priority": 3,
      "passes": true,
      "notes": ""
    },
    {
      "id": "US-004",
      "title": "Decouple resolveNetworkOptions from TUI rendering",
      "description": "As a developer, I want TUI rendering to start without waiting for resolveNetworkOptions() which calls Config.global() to read config files, blocking TUI first-frame by ~50-200ms.",
      "acceptanceCriteria": [
        "tui() call in thread.ts no longer waits for resolveNetworkOptions() — TUI starts with direct RPC communication immediately",
        "resolveNetworkOptions() runs in the background after tui() starts",
        "shouldStartServer logic preserved: checks both CLI arguments AND config values (no behavioral change)",
        "If shouldStartServer is true after background resolution: start HTTP server and transition SDK connection from RPC to HTTP transparently",
        "If shouldStartServer is false (common case): no additional work needed, TUI already running on RPC",
        "Typecheck passes"
      ],
      "priority": 4,
      "passes": true,
      "notes": ""
    },
    {
      "id": "US-005",
      "title": "Eliminate global/index.ts module-level blocking await",
      "description": "As a developer, I want the global directory initialization to not block module import. Currently global/index.ts has module-level await for mkdir and cache version check.",
      "acceptanceCriteria": [
        "Remove await Promise.all([fs.mkdir(...)]) and cache version check from module top-level in global/index.ts",
        "Export Global.ensureDirectories() as an async function instead",
        "Call Global.ensureDirectories() explicitly in CLI entry (index.ts) and Worker entry (worker.ts), NOT inside Log.init()",
        "After Global.ensureDirectories() completes, call Log.flush() to write memory buffer to disk (coordinates with US-003)",
        "Code paths that only read Global.Path.* (pure path computation) do not need to wait for directory creation",
        "Make cache version check async, not blocking the startup chain",
        "Typecheck passes"
      ],
      "priority": 5,
      "passes": true,
      "notes": ""
    },
    {
      "id": "US-006",
      "title": "Add timeout and graceful degradation for remote config fetching",
      "description": "As a developer, I want remote config fetching to have timeouts and fallback so that a slow or unreachable server doesn't block startup indefinitely. Currently fetch() in config.ts has no timeout.",
      "acceptanceCriteria": [
        "Add AbortSignal.timeout(3000) (3-second timeout) to fetch() calls in config.ts",
        "On timeout or network error, degrade to empty config (don't block startup), log at warning level",
        "Cache remote config results to Global.Path.cache/wellknown/{hash}.json with 5-minute TTL",
        "On cache hit, use cached result directly with background async refresh (stale-while-revalidate pattern)",
        "Convert multiple wellknown entry fetch() calls to Promise.allSettled() for parallel execution",
        "Current behavior where fetch failure throws and crashes startup changed to graceful degradation",
        "Typecheck passes"
      ],
      "priority": 6,
      "passes": true,
      "notes": ""
    },
    {
      "id": "US-007",
      "title": "Parallelize plugin loading (install + import + init)",
      "description": "As a developer, I want plugins to be loaded in parallel so that plugin initialization doesn't serialize startup. Currently INTERNAL_PLUGINS and external plugins are loaded serially.",
      "acceptanceCriteria": [
        "Change INTERNAL_PLUGINS loading in Plugin.state() to Promise.allSettled() for parallel execution",
        "Change external plugins' BunProc.install() + import() + fn(input) to Promise.allSettled() for parallel execution",
        "A single plugin failure does not affect other plugins or overall startup",
        "Add 10-second timeout to BunProc.install() to prevent slow npm registry from blocking startup",
        "Verify PluginInput object has no write conflicts during parallel loading (currently read-only — verify)",
        "Typecheck passes"
      ],
      "priority": 7,
      "passes": true,
      "notes": ""
    },
    {
      "id": "US-008",
      "title": "Defer installDependencies out of Config.state() critical path",
      "description": "As a developer, I want installDependencies() deferred out of the Config.state() critical path. Currently it runs bun add + bun install per .opencode/ directory, taking 10s+ per directory on cold npm cache.",
      "acceptanceCriteria": [
        "installDependencies() no longer blocks Config.state() from returning",
        "Option A: run after Config.state() returns with current config, update config async when install completes. Or Option B: check if node_modules/@opencode-ai/plugin exists and version matches — skip install entirely if so",
        "If dependencies need installing, do it in background and trigger config reload upon completion",
        "Parallelize install across multiple .opencode/ directories via Promise.all() when installation is needed",
        "Add timeout to prevent slow npm registry from blocking indefinitely",
        "Typecheck passes"
      ],
      "priority": 8,
      "passes": true,
      "notes": ""
    },
    {
      "id": "US-009",
      "title": "Parallelize Config loading pipeline operations",
      "description": "As a developer, I want independent Config loading operations to run concurrently. Currently Auth.all() and global() run serially, and loadCommand/loadAgent/loadMode/loadPlugin run serially.",
      "acceptanceCriteria": [
        "Run Auth.all() and global() config reading in parallel (global() does not depend on auth)",
        "Parallelize loadCommand(), loadAgent(), loadMode(), loadPlugin() via Promise.all() — these use different glob patterns across different subdirectories and can run concurrently",
        "Merge or parallelize Filesystem.findUp('opencode.jsonc') and Filesystem.findUp('opencode.json') into a single call or parallel calls",
        "No changes to config precedence order or merge logic",
        "Typecheck passes"
      ],
      "priority": 9,
      "passes": true,
      "notes": ""
    },
    {
      "id": "US-010",
      "title": "Parallelize Git metadata fetching",
      "description": "As a developer, I want Git metadata operations to run in parallel so that project detection doesn't waste time on sequential subprocess calls.",
      "acceptanceCriteria": [
        "Run git rev-parse --show-toplevel and git rev-parse --git-common-dir in project.ts via Promise.all() in parallel",
        "Only execute git rev-list --max-parents=0 --all on cache miss (verify existing cache logic effectiveness)",
        "Consider caching git rev-parse results to .git/opencode-metadata with session-level TTL (valid for process lifetime)",
        "Use .git/HEAD mtime as cache invalidation check",
        "Typecheck passes"
      ],
      "priority": 10,
      "passes": true,
      "notes": ""
    },
    {
      "id": "US-011",
      "title": "Parallelize InstanceBootstrap initialization chain",
      "description": "As a developer, I want independent initialization steps in InstanceBootstrap to run concurrently. Depends on US-007 (plugin parallel loading) conclusions for safe parallelization.",
      "acceptanceCriteria": [
        "Pre-validation: confirm Plugin.trigger() is not called during InstanceBootstrap() execution (only called during session runtime)",
        "If pre-validation passes: run Group B (Plugin.init(), LSP.init(), Format.init(), SecurityConfig.load()) via Promise.all() in parallel",
        "If pre-validation fails: only parallelize LSP.init(), Format.init(), SecurityConfig.load(); Plugin.init() must precede them",
        "Run Group C (FileWatcher.init(), File.init(), Vcs.init()) via Promise.all() in parallel (can run concurrently with Group B)",
        "Keep Group A (Share.init(), Snapshot.init(), Truncate.init()) serial — zero-cost, no benefit from parallelization",
        "Typecheck passes"
      ],
      "priority": 11,
      "passes": true,
      "notes": ""
    },
    {
      "id": "US-012",
      "title": "AI SDK lazy loading spike: verify Bun compile + dynamic import",
      "description": "As a developer, I need to verify whether Bun compile mode supports dynamic import() for AI SDK providers before implementing lazy loading.",
      "acceptanceCriteria": [
        "Create a minimal test script under script/ that uses import('@ai-sdk/anthropic') dynamic import",
        "Compile with bun build --compile to a binary",
        "Run the compiled binary and verify dynamic import succeeds",
        "Test both static string path (import('@ai-sdk/anthropic')) and Map-based registry pattern with computed keys",
        "Document findings: which patterns work, which fail, error messages if any",
        "If dynamic import fails: document the fallback approach (grouped loading or lazy evaluation via object lookup)",
        "Typecheck passes"
      ],
      "priority": 12,
      "passes": false,
      "notes": ""
    },
    {
      "id": "US-013",
      "title": "Implement AI SDK provider lazy loading based on spike results",
      "description": "As a developer, I want AI SDK providers imported on-demand instead of all 20+ at module level so that unused providers don't add to startup time. Implementation approach depends on US-012 spike results.",
      "acceptanceCriteria": [
        "If Bun compile supports dynamic import: convert 20+ import statements in provider/provider.ts to dynamic import() inside factory functions. Each provider only imported when user selects it. Use Map<string, () => Promise<SDK>> registry pattern. Cache imported provider references to avoid duplicate loading",
        "If Bun compile does NOT support dynamic import: group providers into 'common' (anthropic, openai, google) and 'other'. Eager-load 'common', lazy-load 'other' via conditional require or code splitting. Or use lazy evaluation via object lookup (no dynamic import needed)",
        "Typecheck passes"
      ],
      "priority": 13,
      "passes": false,
      "notes": ""
    },
    {
      "id": "US-014",
      "title": "LSP and FileWatcher lazy initialization",
      "description": "As a developer, I want LSP servers and file watcher to initialize lazily so they don't add to the critical startup path.",
      "acceptanceCriteria": [
        "Change LSP.init() in InstanceBootstrap() from await to fire-and-forget (LSP.init().catch(log.error)) or remove entirely, letting LSP auto-initialize on first tool invocation",
        "Verify whether FileWatcher.init() is already lazy via its state() — if so, FileWatcher.init() can be removed from bootstrap",
        "Verify LSP server processes only spawn on first use of that language's LSP features (check if already the case)",
        "After bootstrap completes, pre-warm LSP and FileWatcher in background (setTimeout(0) or queueMicrotask)",
        "Ensure TUI first-frame rendering does not wait for LSP and FileWatcher readiness",
        "Typecheck passes"
      ],
      "priority": 14,
      "passes": false,
      "notes": ""
    },
    {
      "id": "US-015",
      "title": "Evaluate provider models-snapshot loading optimization",
      "description": "As a developer, I want the provider models snapshot to be loaded efficiently. The 1.4MB models-snapshot.ts file may have significant parse/eval overhead at runtime.",
      "acceptanceCriteria": [
        "Use US-001 profiling to confirm models-snapshot.ts runtime import duration",
        "If duration > 50ms: convert models-snapshot to JSON format, load with Bun.file().json() (JSON.parse is ~10x faster than JS eval)",
        "If duration > 100ms: consider lazy loading (only on provider selection UI or first model invocation)",
        "If duration < 50ms: mark as not needing optimization and document the finding",
        "Typecheck passes"
      ],
      "priority": 15,
      "passes": false,
      "notes": ""
    },
    {
      "id": "US-016",
      "title": "Verify TUI first-frame rendering meets target after optimizations",
      "description": "As a developer, I want to verify that TUI first-frame time meets the <200ms target after US-002 (terminal bg), US-003 (Log.init), and US-004 (resolveNetworkOptions) are complete.",
      "acceptanceCriteria": [
        "Re-measure TUI first-frame time using --startup-trace from US-001",
        "First-frame time (from process start to Logo render) < 200ms",
        "Verify resolveNetworkOptions no longer blocks tui() call",
        "Verify getTerminalBackgroundColor uses cache on subsequent launches",
        "If user enters a message before bootstrap completes, verify current behavior (whether status === 'loading' in sync.tsx prevents submission)",
        "Typecheck passes"
      ],
      "priority": 16,
      "passes": false,
      "notes": ""
    },
    {
      "id": "US-017",
      "title": "Add startup performance regression tests",
      "description": "As a developer, I want automated startup time tracking so that future changes don't regress cold start performance. Thresholds based on measured data from optimizations.",
      "acceptanceCriteria": [
        "Add test/perf/startup.test.ts performance test",
        "Test spawns opencode --startup-trace --help and parses trace output",
        "Assert per-phase durations do not exceed preset thresholds (initial thresholds set to 1.5x of current baseline, tightened after optimization)",
        "Test runs optionally in CI (controlled by OPENCODE_PERF_TEST=1 environment variable)",
        "No dependency on external services (mock remote config fetch)",
        "Typecheck passes"
      ],
      "priority": 17,
      "passes": false,
      "notes": ""
    }
  ]
}
