{
  "project": "OpenCode",
  "branchName": "ralph/security-allowlist",
  "description": "Security Access Control Allowlist - restrict LLM access to explicitly permitted files/directories via allowlist in .opencode-security.json",
  "userStories": [
    {
      "id": "US-001",
      "title": "Add allowlist schema and ResolvedSecurityConfig type",
      "description": "As a developer, I need the type definitions for the allowlist feature before any logic can be implemented. Add AllowlistEntry Zod schema, AllowlistLayer interface, ResolvedSecurityConfig interface, and the allowlist field to securityConfigSchema. All changes in packages/opencode/src/security/schema.ts only.",
      "acceptanceCriteria": [
        "Add AllowlistEntry Zod schema: z.object({ pattern: z.string(), type: z.enum(['directory', 'file']) })",
        "Export AllowlistEntry type via z.infer",
        "Add AllowlistLayer interface: { source: string, entries: AllowlistEntry[] } — source is config file path, entries are the allowlist entries from that config level",
        "Add ResolvedSecurityConfig interface extending SecurityConfig with resolvedAllowlist: AllowlistLayer[]",
        "Add optional allowlist field to securityConfigSchema: z.array(AllowlistEntry).optional()",
        "Existing configs without allowlist field still parse successfully (backward compatible)",
        "Config with allowlist: [{ pattern: 'src/**', type: 'directory' }] parses successfully",
        "Typecheck passes"
      ],
      "priority": 1,
      "passes": true,
      "notes": "Schema-only change. No logic changes. File: packages/opencode/src/security/schema.ts. Follow existing namespace pattern (SecuritySchema). AllowlistEntry uses same RuleType enum as deny rules."
    },
    {
      "id": "US-002",
      "title": "Refactor config.ts to use ResolvedSecurityConfig and update merge signature",
      "description": "As a developer, I want config.ts to use ResolvedSecurityConfig as its internal type and build AllowlistLayer[] during config merging, so that checkAccess() and all callers have access to resolved allowlist layers. This includes changing mergeSecurityConfigs() signature, updating getSecurityConfig() return type, and adding empty-allowlist warning.",
      "acceptanceCriteria": [
        "Change currentConfig variable type from SecurityConfig to ResolvedSecurityConfig",
        "Update emptyConfig to include resolvedAllowlist: [] (no restriction by default)",
        "Change getSecurityConfig() return type to ResolvedSecurityConfig",
        "Change mergeSecurityConfigs() input from SecurityConfig[] to { config: SecurityConfig, path: string }[] and return type to ResolvedSecurityConfig",
        "In mergeSecurityConfigs(), each config that defines allowlist produces one AllowlistLayer in resolvedAllowlist with source set to the config file path",
        "If neither config defines allowlist, resolvedAllowlist is empty array",
        "In loadSecurityConfig(), if single config has allowlist defined, create one AllowlistLayer with source set to config file path; if not defined, resolvedAllowlist is []",
        "When allowlist is present but is empty array [], log warning: 'Empty allowlist configured — all LLM operations will be denied. No files are accessible to the LLM.'",
        "Update all callers of getSecurityConfig() if needed — most callers only access existing fields so changes should be minimal since ResolvedSecurityConfig extends SecurityConfig",
        "Typecheck passes"
      ],
      "priority": 2,
      "passes": true,
      "notes": "Primary file: packages/opencode/src/security/config.ts. Depends on US-001 for types. ResolvedSecurityConfig extends SecurityConfig so most callers need no change. The merge function now needs { config, path }[] input — findSecurityConfigs() already returns this shape."
    },
    {
      "id": "US-003",
      "title": "Wire up multi-level config loading in bootstrap",
      "description": "As a developer, I want the bootstrap flow to use findSecurityConfigs() + mergeSecurityConfigs() instead of single-file loading, so that hierarchical configs and multi-level allowlists are properly loaded.",
      "acceptanceCriteria": [
        "Refactor loadSecurityConfig() to call findSecurityConfigs(projectRoot) to discover all .opencode-security.json files from project root up to git root",
        "Pass discovered configs through mergeSecurityConfigs() to produce the final merged ResolvedSecurityConfig",
        "Bootstrap call in packages/opencode/src/project/bootstrap.ts still calls SecurityConfig.loadSecurityConfig(Instance.directory) — function signature unchanged",
        "Single-config scenario: only one .opencode-security.json exists → behaves identically to before",
        "No-config scenario: no .opencode-security.json found → returns empty config as before",
        "Multi-config scenario: parent and child configs merged correctly — rules unioned, roles validated, allowlist layers preserved per-level",
        "Typecheck passes"
      ],
      "priority": 3,
      "passes": true,
      "notes": "Primary files: packages/opencode/src/security/config.ts (loadSecurityConfig refactor), packages/opencode/src/project/bootstrap.ts (verify). findSecurityConfigs() and mergeSecurityConfigs() already exist — this story wires them into the main loading path."
    },
    {
      "id": "US-004",
      "title": "Enforce allowlist in checkAccess with evaluation order and audit logging",
      "description": "As a developer, I want checkAccess() to enforce the allowlist for llm operations with correct priority (deny > allowlist > default-allow), friendly denial messages, symlink handling, and audit logging.",
      "acceptanceCriteria": [
        "Evaluation order in checkAccess(): 1) resolve symlinks, 2) check deny rules — if denied return DENIED, 3) if operation is not 'llm' return ALLOWED, 4) if resolvedAllowlist has layers check file against every layer, 5) if all layers pass or no allowlist configured return ALLOWED",
        "For each AllowlistLayer, file must match at least one AllowlistEntry to pass (AND across layers, OR within entries)",
        "AllowlistEntry with type 'directory' matches using same logic as deny rule directory matching (pattern itself + pattern/**)",
        "AllowlistEntry with type 'file' matches using same logic as deny rule file matching (exact pattern match via minimatch with matchBase: true)",
        "read and write operations NOT affected by allowlist — only llm is restricted",
        "Symlink handling: resolve symlinks first, check resolved (real) path against allowlist — real file location determines access",
        "Denial message is user-friendly and actionable: includes rejected file path, which layer's source config rejected it, and suggestion to add matching entry with example format",
        "When a file is denied due to allowlist, call SecurityAudit.logSecurityEvent() with path, operation, role, allowed: false, reason with allowlist context and rejecting layer source",
        "When no allowlist configured (resolvedAllowlist empty), behavior identical to current (all files accessible)",
        "Typecheck passes"
      ],
      "priority": 4,
      "passes": true,
      "notes": "Primary file: packages/opencode/src/security/access.ts. Reuse existing matchPath() for AllowlistEntry matching. Add allowlist check AFTER the deny rule loop but BEFORE returning allowed: true. Early exit on first failing layer."
    },
    {
      "id": "US-005",
      "title": "Unit tests for allowlist enforcement",
      "description": "As a developer, I want comprehensive unit tests covering all allowlist scenarios: basic matching, deny rule interaction, operation filtering, empty/missing allowlist, multi-layer merge, symlink, and audit logging.",
      "acceptanceCriteria": [
        "Test: file matches allowlist entry (type: file), no deny rule → llm allowed",
        "Test: file matches allowlist entry (type: directory), no deny rule → llm allowed for nested files",
        "Test: file NOT in allowlist → llm denied with friendly actionable message (includes rejected path, rejecting layer source, suggestion to add entry)",
        "Test: file in allowlist but covered by deny rule with llm in deniedOperations → llm denied (deny wins)",
        "Test: read and write operations unaffected by allowlist (read allowed even if file not in allowlist)",
        "Test: empty allowlist array [] → all llm operations denied, warning logged",
        "Test: no allowlist field → all files accessible (backward compatible)",
        "Test: directory entry { pattern: 'src/**', type: 'directory' } matches src/foo/bar.ts",
        "Test: file entry { pattern: 'README.md', type: 'file' } matches only README.md, not README.md.bak",
        "Test: symlink resolved path checked against allowlist",
        "Test: two-layer allowlist — file must match both layers to be allowed",
        "Test: child config cannot expand parent allowlist (parent allows src/**, child allows src/** + test/** → test/** still denied by parent layer)",
        "Test: single-layer allowlist (only parent or only child defines it)",
        "Test: multi-level config loading via findSecurityConfigs + mergeSecurityConfigs produces correct ResolvedSecurityConfig with AllowlistLayer[]",
        "Test: audit log records allowlist denial events via SecurityAudit.logSecurityEvent()",
        "All tests pass with bun test --cwd packages/opencode",
        "Typecheck passes"
      ],
      "priority": 5,
      "passes": true,
      "notes": "Test file: packages/opencode/test/security/access_control_cases/unit/allowlist.test.ts. Use existing test helpers: setupSecurityConfig(config, dir?) + teardownSecurityConfig(). setupSecurityConfig creates .git dir automatically. Use fs.realpathSync() on temp dirs for absolute rule patterns (macOS /private/var/ canonicalization). Follow existing test patterns in the same directory."
    },
    {
      "id": "US-006",
      "title": "Update security check CLI command for allowlist",
      "description": "As a user, I want the 'opencode security check <path>' CLI command to show allowlist status so I can verify whether a file is permitted by the allowlist.",
      "acceptanceCriteria": [
        "security check output includes whether the file matches the current allowlist",
        "If no allowlist configured, output indicates 'No allowlist configured (all files accessible)'",
        "If allowlist configured, output shows per-layer match status: which layer matched (with source path) and which pattern matched, or 'Not matched' per layer",
        "Typecheck passes"
      ],
      "priority": 6,
      "passes": false,
      "notes": "CLI command location: packages/opencode/src/cli/cmd/security/. Reads resolvedAllowlist from getSecurityConfig(). Reuse the same AllowlistEntry matching logic from access.ts."
    }
  ]
}
